/*
 * generated by Xtext
 */
package person.zhoujg.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import person.zhoujg.feature.Atom;
import person.zhoujg.feature.AttributePart;
import person.zhoujg.feature.BasicExpr;
import person.zhoujg.feature.Feature;
import person.zhoujg.feature.FeatureBody;
import person.zhoujg.feature.FeatureExpr;
import person.zhoujg.feature.FeaturePackage;
import person.zhoujg.feature.Literal;
import person.zhoujg.feature.LogicExpr;
import person.zhoujg.feature.RuleBody;
import person.zhoujg.services.FeatureGrammarAccess;

@SuppressWarnings("all")
public class FeatureSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FeatureGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == FeaturePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case FeaturePackage.ATOM:
				sequence_Atom(context, (Atom) semanticObject); 
				return; 
			case FeaturePackage.ATTRIBUTE_PART:
				sequence_AttributePart(context, (AttributePart) semanticObject); 
				return; 
			case FeaturePackage.BASIC_EXPR:
				sequence_BasicExpr(context, (BasicExpr) semanticObject); 
				return; 
			case FeaturePackage.FEATURE:
				if(context == grammarAccess.getAttributeRule()) {
					sequence_Attribute(context, (Feature) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFeatureDeclarationRule()) {
					sequence_FeatureDeclaration(context, (Feature) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRootDeclarationRule()) {
					sequence_RootDeclaration(context, (Feature) semanticObject); 
					return; 
				}
				else break;
			case FeaturePackage.FEATURE_BODY:
				sequence_FeatureBody(context, (FeatureBody) semanticObject); 
				return; 
			case FeaturePackage.FEATURE_EXPR:
				sequence_FeatureExpr(context, (FeatureExpr) semanticObject); 
				return; 
			case FeaturePackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case FeaturePackage.LOGIC_EXPR:
				sequence_LogicExpr(context, (LogicExpr) semanticObject); 
				return; 
			case FeaturePackage.RULE_BODY:
				sequence_RuleBody(context, (RuleBody) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (literal=Literal | sub=LogicExpr)
	 */
	protected void sequence_Atom(EObject context, Atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (attr+=Attribute*)
	 */
	protected void sequence_AttributePart(EObject context, AttributePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=AttributeType name=ID)
	 */
	protected void sequence_Attribute(EObject context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (lExpr=Atom (compOp=ComparationOP rExpr=Atom)?)
	 */
	protected void sequence_BasicExpr(EObject context, BasicExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (attrs=AttributePart? features+=FeatureDeclaration* ruleBody=RuleBody?)
	 */
	protected void sequence_FeatureBody(EObject context, FeatureBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (outCard=StandaloneCardinality? (name=ID | ref=[Feature|ID]) inCard=GroupCardinality? body=FeatureBody?)
	 */
	protected void sequence_FeatureDeclaration(EObject context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=LogicExpr op=FeatureOP right=LogicExpr)
	 */
	protected void sequence_FeatureExpr(EObject context, FeatureExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FeaturePackage.Literals.FEATURE_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeaturePackage.Literals.FEATURE_EXPR__LEFT));
			if(transientValues.isValueTransient(semanticObject, FeaturePackage.Literals.FEATURE_EXPR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeaturePackage.Literals.FEATURE_EXPR__OP));
			if(transientValues.isValueTransient(semanticObject, FeaturePackage.Literals.FEATURE_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FeaturePackage.Literals.FEATURE_EXPR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFeatureExprAccess().getLeftLogicExprParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFeatureExprAccess().getOpFeatureOPEnumRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getFeatureExprAccess().getRightLogicExprParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (str=STRING | int=INT | bool=BOOL | name=[Feature|QualifiedName])
	 */
	protected void sequence_Literal(EObject context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((leftLogicExpr=LogicExpr_LogicExpr_2_0 logicOP=LogicOP right=BasicExpr) | leftLogicExpr=BasicExpr)
	 */
	protected void sequence_LogicExpr(EObject context, LogicExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID inCard=GroupCardinality? body=FeatureBody?)
	 */
	protected void sequence_RootDeclaration(EObject context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (rules+=FeatureExpr*)
	 */
	protected void sequence_RuleBody(EObject context, RuleBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
